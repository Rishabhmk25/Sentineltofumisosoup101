/**
 * FingerprintJS Server API Node.js SDK v5.2.0 - Copyright (c) FingerprintJS, Inc, 2024 (https://fingerprint.com)
 * Licensed under the MIT (http://www.opensource.org/licenses/mit-license.php) license.
 */

import crypto, { createDecipheriv } from 'crypto';
import { inflateRaw } from 'zlib';
import { promisify } from 'util';
import { Buffer } from 'buffer';

var Region;
(function (Region) {
    Region["EU"] = "EU";
    Region["AP"] = "AP";
    Region["Global"] = "Global";
})(Region || (Region = {}));
var AuthenticationMode;
(function (AuthenticationMode) {
    AuthenticationMode["AuthHeader"] = "AuthHeader";
    AuthenticationMode["QueryParameter"] = "QueryParameter";
})(AuthenticationMode || (AuthenticationMode = {}));

var version = "5.2.0";

const euRegionUrl = 'https://eu.api.fpjs.io/';
const apRegionUrl = 'https://ap.api.fpjs.io/';
const globalRegionUrl = 'https://api.fpjs.io/';
function getIntegrationInfo() {
    return `fingerprint-pro-server-node-sdk/${version}`;
}
function serializeQueryStringParams(params) {
    const urlSearchParams = new URLSearchParams(Object.entries(params));
    return urlSearchParams.toString();
}
function getServerApiUrl(region) {
    switch (region) {
        case Region.EU:
            return euRegionUrl;
        case Region.AP:
            return apRegionUrl;
        case Region.Global:
            return globalRegionUrl;
        default:
            throw new Error('Unsupported region');
    }
}
/**
 * Formats a URL for the FingerprintJS server API by replacing placeholders and
 * appending query string parameters.
 *
 * @internal
 *
 * @param {GetRequestPathOptions<Path, Method>} options
 * @param {Path} options.path - The path of the API endpoint
 * @param {string[]} [options.pathParams] - Path parameters to be replaced in the path
 * @param {string} [options.apiKey] - API key to be included in the query string
 * @param {QueryParams<Path, Method>["queryParams"]} [options.queryParams] - Query string
 *   parameters to be appended to the URL
 * @param {Region} options.region - The region of the API endpoint
 * @param {Method} options.method - The method of the API endpoint
 *
 * @returns {string} The formatted URL with parameters replaced and query string
 *   parameters appended
 */
function getRequestPath({ path, pathParams, apiKey, queryParams, region, 
// method mention here so that it can be referenced in JSDoc
// eslint-disable-next-line @typescript-eslint/no-unused-vars
method: _, }) {
    // Step 1: Extract the path parameters (placeholders) from the path
    const placeholders = Array.from(path.matchAll(/{(.*?)}/g)).map((match) => match[1]);
    // Step 2: Replace the placeholders with provided pathParams
    let formattedPath = path;
    placeholders.forEach((placeholder, index) => {
        if (pathParams?.[index]) {
            formattedPath = formattedPath.replace(`{${placeholder}}`, pathParams[index]);
        }
        else {
            throw new Error(`Missing path parameter for ${placeholder}`);
        }
    });
    const queryStringParameters = {
        ...(queryParams ?? {}),
        ii: getIntegrationInfo(),
    };
    if (apiKey) {
        queryStringParameters.api_key = apiKey;
    }
    const url = new URL(getServerApiUrl(region));
    url.pathname = formattedPath;
    url.search = serializeQueryStringParams(queryStringParameters);
    return url.toString();
}

class SdkError extends Error {
    response;
    constructor(message, response, cause) {
        super(message, { cause });
        this.response = response;
        this.name = this.constructor.name;
    }
}
class ApiError extends SdkError {
    // HTTP Status code
    statusCode;
    // API error code
    errorCode;
    // API error response
    responseBody;
    // Raw HTTP response
    response;
    constructor(message, body, statusCode, errorCode, response) {
        super(message, response);
        this.responseBody = body;
        this.response = response;
        this.errorCode = errorCode;
        this.statusCode = statusCode;
    }
    static unknown(response) {
        return new ApiError('Unknown error', undefined, response.status, response.statusText, response);
    }
}

function toError(e) {
    if (e && typeof e === 'object' && 'message' in e) {
        return e;
    }
    return new Error(String(e));
}

async function copyResponseJson(response) {
    try {
        return await response.clone().json();
    }
    catch (e) {
        throw new SdkError('Failed to parse JSON response', response, toError(e));
    }
}

function getRetryAfter(response) {
    const retryAfter = parseInt(response.headers.get('retry-after') ?? '');
    return Number.isNaN(retryAfter) ? 0 : retryAfter;
}

class CommonError429 extends ApiError {
    retryAfter = 0;
    constructor(body, response) {
        super(body.error?.message ?? 'Too many requests', body, 429, body.error?.code ?? 'TooManyRequests', response);
        this.retryAfter = getRetryAfter(response);
    }
}
class CommonError403 extends ApiError {
    constructor(body, response) {
        super(body.error?.message ?? 'Forbidden', body, 403, body.error?.code ?? 'Forbidden', response);
    }
}

class DeleteVisit404Error extends ApiError {
    constructor(body, response) {
        super(body.error?.message ?? 'Visit not found', body, 404, body.error?.code ?? 'VisitorNotFound', response);
    }
}
class DeleteVisit403Error extends ApiError {
    constructor(body, response) {
        super(body.error?.message ?? 'Forbidden', body, 403, body.error?.code ?? 'Forbidden', response);
    }
}
class DeleteVisit400Error extends ApiError {
    constructor(body, response) {
        super(body.error?.message ?? 'Visit not found', body, 400, body.error?.code ?? 'RequestCannotBeParsed', response);
    }
}
class VisitorsError404 extends ApiError {
    constructor(body, response) {
        super(body.error?.message ?? 'Visitor not found', body, 404, body.error?.code ?? 'VisitorNotFound', response);
    }
}
class VisitorsError429 extends ApiError {
    retryAfter = 0;
    constructor(body, response) {
        super(body.error, body, 429, 'TooManyRequests', response);
        this.retryAfter = getRetryAfter(response);
    }
}
class VisitorsError403 extends ApiError {
    constructor(body, response) {
        super(body.error, body, 403, 'Forbidden', response);
    }
}
class VisitorsError400 extends ApiError {
    constructor(body, response) {
        super(body.error?.message ?? 'Request cannot be parsed', body, 400, 'RequestCannotBeParsed', response);
    }
}
const DELETE_VISITS_ERRORS = [
    DeleteVisit404Error,
    DeleteVisit403Error,
    DeleteVisit400Error,
    CommonError429,
];
function isDeleteVisitorsError(error) {
    return DELETE_VISITS_ERRORS.some((errorConstructor) => error instanceof errorConstructor);
}
const VISITOR_ERRORS = [VisitorsError403, VisitorsError429];
function isVisitorsError(error) {
    return VISITOR_ERRORS.some((errorConstructor) => error instanceof errorConstructor);
}
const RELATED_VISITORS_ERRORS = [VisitorsError400, VisitorsError403, VisitorsError404, VisitorsError429];
function isRelatedVisitorsError(error) {
    return RELATED_VISITORS_ERRORS.some((errorConstructor) => error instanceof errorConstructor);
}

class EventError403 extends ApiError {
    constructor(body, response) {
        super(body.error?.message ?? 'Forbidden', body, 403, body.error?.code ?? 'Forbidden', response);
    }
}
class EventError404 extends ApiError {
    constructor(body, response) {
        super(body.error?.message ?? 'request id is not found', body, 404, body.error?.code ?? 'RequestNotFound', response);
    }
}
class UpdateEventError400 extends ApiError {
    constructor(body, response) {
        super(body.error?.message ?? 'Bad request', body, 400, body.error?.code ?? 'BadRequest', response);
    }
}
class UpdateEventError403 extends ApiError {
    constructor(body, response) {
        super(body.error?.message ?? 'Forbidden', body, 403, body.error?.code ?? 'Forbidden', response);
    }
}
class UpdateEventError404 extends ApiError {
    constructor(body, response) {
        super(body.error?.message ?? 'Request id is not found', body, 404, body.error?.code ?? 'RequestNotFound', response);
    }
}
class UpdateEventError409 extends ApiError {
    constructor(body, response) {
        super(body.error?.message ?? 'Conflict', body, 409, body.error?.code ?? 'Conflict', response);
    }
}
const EVENT_ERRORS = [EventError403, EventError404];
function isEventError(error) {
    return EVENT_ERRORS.some((errorConstructor) => error instanceof errorConstructor);
}
const UPDATE_EVENT_ERRORS = [UpdateEventError400, UpdateEventError403, UpdateEventError404, UpdateEventError409];
function isUpdateEventError(error) {
    return UPDATE_EVENT_ERRORS.some((errorConstructor) => error instanceof errorConstructor);
}

class FingerprintJsServerApiClient {
    region;
    apiKey;
    authenticationMode;
    fetch;
    static DEFAULT_RETRY_AFTER = 1;
    /**
     * FingerprintJS server API client used to fetch data from FingerprintJS
     * @constructor
     * @param {Options} options - Options for FingerprintJS server API client
     */
    constructor(options) {
        if (!options.apiKey) {
            throw Error('Api key is not set');
        }
        this.region = options.region ?? Region.Global;
        this.apiKey = options.apiKey;
        this.authenticationMode = options.authenticationMode ?? AuthenticationMode.AuthHeader; // Default auth mode is AuthHeader
        this.fetch = options.fetch ?? fetch;
    }
    /**
     * Retrieves a specific identification event with the information from each activated product — Identification and all active [Smart signals](https://dev.fingerprint.com/docs/smart-signals-overview).
     *
     * @param requestId - identifier of the event
     *
     * @returns {Promise<EventResponse>} - promise with event response. For more information, see the [Server API documentation](https://dev.fingerprint.com/reference/getevent).
     *
     * @example
     * ```javascript
     * client
     *  .getEvent('<requestId>')
     *  .then((result) => console.log(result))
     *  .catch((err) => {
     *    if (isEventError(err)) {
     *      // You can also access the raw response
     *      console.log(err.response)
     *      console.log(`error ${err.statusCode}: `, err.message)
     *    } else {
     *      console.log('unknown error: ', err)
     *    }
     *  })
     * ```
     * */
    async getEvent(requestId) {
        if (!requestId) {
            throw new TypeError('requestId is not set');
        }
        const url = getRequestPath({
            path: '/events/{request_id}',
            region: this.region,
            apiKey: this.getQueryApiKey(),
            pathParams: [requestId],
            method: 'get',
        });
        const headers = this.getHeaders();
        const response = await this.fetch(url, {
            method: 'GET',
            headers,
        });
        const jsonResponse = await copyResponseJson(response);
        if (response.status === 200) {
            return jsonResponse;
        }
        switch (response.status) {
            case 403:
                throw new EventError403(jsonResponse, response);
            case 404:
                throw new EventError404(jsonResponse, response);
            default:
                throw ApiError.unknown(response);
        }
    }
    /**
     * Update an event with a given request ID
     * @description Change information in existing events specified by `requestId` or *flag suspicious events*.
     *
     * When an event is created, it is assigned `linkedId` and `tag` submitted through the JS agent parameters. This information might not be available on the client so the Server API allows for updating the attributes after the fact.
     *
     * **Warning** It's not possible to update events older than 10 days.
     *
     * @param body - Data to update the event with.
     * @param requestId The unique event [identifier](https://dev.fingerprint.com/docs/js-agent#requestid).
     *
     * @return {Promise<void>}
     *
     * @example
     * ```javascript
     * const body = {
     *  linkedId: 'linked_id',
     *  suspect: false,
     * }
     *
     * client
     *   .updateEvent(body, '<requestId>')
     *   .then(() => {
     *     // Event was successfully updated
     *   })
     *   .catch((error) => {
     *     if (isUpdateEventError(error)) {
     *       console.log(error.statusCode, error.message)
     *     }
     *   })
     * ```
     */
    async updateEvent(body, requestId) {
        if (!body) {
            throw new TypeError('body is not set');
        }
        if (!requestId) {
            throw new TypeError('requestId is not set');
        }
        const url = getRequestPath({
            path: '/events/{request_id}',
            region: this.region,
            apiKey: this.getQueryApiKey(),
            pathParams: [requestId],
            method: 'put',
        });
        const headers = this.getHeaders();
        const response = await this.fetch(url, {
            method: 'PUT',
            headers,
            body: JSON.stringify(body),
        });
        if (response.status === 200) {
            return;
        }
        const jsonResponse = await copyResponseJson(response);
        switch (response.status) {
            case 400:
                throw new UpdateEventError400(jsonResponse, response);
            case 403:
                throw new UpdateEventError403(jsonResponse, response);
            case 404:
                throw new UpdateEventError404(jsonResponse, response);
            case 409:
                throw new UpdateEventError409(jsonResponse, response);
            default:
                throw ApiError.unknown(response);
        }
    }
    /**
     * Delete data by visitor ID
     * Request deleting all data associated with the specified visitor ID. This API is useful for compliance with privacy regulations. All delete requests are queued:
     * Recent data (10 days or newer) belonging to the specified visitor will be deleted within 24 hours. * Data from older (11 days or more) identification events  will be deleted after 90 days.
     * If you are interested in using this API, please [contact our support team](https://fingerprint.com/support/) to activate it for you. Otherwise, you will receive a 403.
     *
     * @param visitorId The [visitor ID](https://dev.fingerprint.com/docs/js-agent#visitorid) you want to delete.*
     *
     * @return {Promise<void>} Promise that resolves when the deletion request is successfully queued
     *
     * @example
     * ```javascript
     * client
     *   .deleteVisitorData('<visitorId>')
     *   .then(() => {
     *     // Data deletion request was successfully queued
     *   })
     *   .catch((error) => {
     *     if (isDeleteVisitorError(error)) {
     *       console.log(error.statusCode, error.message)
     *     }
     *   })
     * ```
     */
    async deleteVisitorData(visitorId) {
        if (!visitorId) {
            throw TypeError('VisitorId is not set');
        }
        const url = getRequestPath({
            path: '/visitors/{visitor_id}',
            region: this.region,
            apiKey: this.getQueryApiKey(),
            pathParams: [visitorId],
            method: 'delete',
        });
        const headers = this.getHeaders();
        const response = await this.fetch(url, {
            method: 'DELETE',
            headers,
        });
        if (response.status === 200) {
            return;
        }
        const jsonResponse = await copyResponseJson(response);
        switch (response.status) {
            case 429:
                throw new CommonError429(jsonResponse, response);
            case 404:
                throw new DeleteVisit404Error(jsonResponse, response);
            case 403:
                throw new DeleteVisit403Error(jsonResponse, response);
            case 400:
                throw new DeleteVisit400Error(jsonResponse, response);
            default:
                throw ApiError.unknown(response);
        }
    }
    /**
     * @deprecated Please use {@link FingerprintJsServerApiClient.getVisits} instead
     * */
    async getVisitorHistory(visitorId, filter) {
        return this.getVisits(visitorId, filter);
    }
    /**
     * Retrieves event history for the specific visitor using the given filter, returns a promise with visitor history response.
     *
     * @param {string} visitorId - Identifier of the visitor
     * @param {VisitorHistoryFilter} filter - Visitor history filter
     * @param {string} filter.limit - limit scanned results
     * @param {string} filter.request_id - filter visits by `requestId`.
     * @param {string} filter.linked_id - filter visits by your custom identifier.
     * @param {string} filter.paginationKey - use `paginationKey` to get the next page of results.   When more results are available (e.g., you requested 200 results using `limit` parameter, but a total of 600 results are available), the `paginationKey` top-level attribute is added to the response. The key corresponds to the `requestId` of the last returned event. In the following request, use that value in the `paginationKey` parameter to get the next page of results:
     *
     *   1. First request, returning most recent 200 events: `GET api-base-url/visitors/:visitorId?limit=200`
     *   2. Use `response.paginationKey` to get the next page of results: `GET api-base-url/visitors/:visitorId?limit=200&paginationKey=1683900801733.Ogvu1j`
     *
     *   Pagination happens during scanning and before filtering, so you can get less visits than the `limit` you specified with more available on the next page. When there are no more results available for scanning, the `paginationKey` attribute is not returned.
     * @example
     * ```javascript
     * client
     *   .getVisits('<visitorId>', { limit: 1 })
     *   .then((visitorHistory) => {
     *     console.log(visitorHistory)
     *   })
     *   .catch((error) => {
     *     if (isVisitorsError(error)) {
     *       console.log(error.statusCode, error.message)
     *       if (error.status === 429) {
     *         retryLater(error.retryAfter) // Needs to be implemented on your side
     *       }
     *     }
     *   })
     * ```
     */
    async getVisits(visitorId, filter) {
        if (!visitorId) {
            throw TypeError('VisitorId is not set');
        }
        const url = getRequestPath({
            path: '/visitors/{visitor_id}',
            region: this.region,
            apiKey: this.getQueryApiKey(),
            pathParams: [visitorId],
            method: 'get',
            queryParams: filter,
        });
        const headers = this.getHeaders();
        const response = await this.fetch(url, {
            method: 'GET',
            headers,
        });
        const jsonResponse = await copyResponseJson(response);
        if (response.status === 200) {
            return jsonResponse;
        }
        switch (response.status) {
            case 403:
                throw new VisitorsError403(jsonResponse, response);
            case 429:
                throw new VisitorsError429(jsonResponse, response);
            default:
                throw ApiError.unknown(response);
        }
    }
    /**
     * Related visitors API lets you link web visits and in-app browser visits that originated from the same mobile device.
     * It searches the past 6 months of identification events to find the visitor IDs that belong to the same mobile device as the given visitor ID.
     * ⚠️ Please note that this API is not enabled by default and is billable separately. ⚠️
     * If you would like to use Related visitors API, please contact our [support team](https://fingerprint.com/support).
     * To learn more, see [Related visitors API reference](https://dev.fingerprint.com/reference/related-visitors-api).
     *
     * @param {RelatedVisitorsFilter} filter - Related visitors filter
     * @param {string} filter.visitorId - The [visitor ID](https://dev.fingerprint.com/docs/js-agent#visitorid) for which you want to find the other visitor IDs that originated from the same mobile device.
     *
     * @example
     * ```javascript
     * client
     *   .getRelatedVisitors({ visitor_id: '<visitorId>' })
     *   .then((relatedVisits) => {
     *     console.log(relatedVisits)
     *   })
     *   .catch((error) => {
     *     if (isRelatedVisitorsError(error)) {
     *       console.log(error.statusCode, error.message)
     *       if (error.status === 429) {
     *         retryLater(error.retryAfter) // Needs to be implemented on your side
     *       }
     *     }
     *   })
     * ```
     */
    async getRelatedVisitors(filter) {
        const url = getRequestPath({
            path: '/related-visitors',
            region: this.region,
            apiKey: this.getQueryApiKey(),
            method: 'get',
            queryParams: filter,
        });
        const headers = this.getHeaders();
        const response = await this.fetch(url, {
            method: 'GET',
            headers,
        });
        const jsonResponse = await copyResponseJson(response);
        if (response.status === 200) {
            return jsonResponse;
        }
        switch (response.status) {
            case 400:
                throw new VisitorsError400(jsonResponse, response);
            case 403:
                throw new VisitorsError403(jsonResponse, response);
            case 404:
                throw new VisitorsError404(jsonResponse, response);
            case 429:
                throw new VisitorsError429(jsonResponse, response);
            default:
                throw ApiError.unknown(response);
        }
    }
    getHeaders() {
        return this.authenticationMode === AuthenticationMode.AuthHeader ? { 'Auth-API-Key': this.apiKey } : undefined;
    }
    getQueryApiKey() {
        return this.authenticationMode === AuthenticationMode.QueryParameter ? this.apiKey : undefined;
    }
}

class UnsealError extends Error {
    key;
    error;
    constructor(key, error) {
        let msg = `Unable to decrypt sealed data`;
        if (error) {
            msg = msg.concat(`: ${error.message}`);
        }
        super(msg);
        this.key = key;
        this.error = error;
        this.name = 'UnsealError';
    }
}
class UnsealAggregateError extends Error {
    errors;
    constructor(errors) {
        super('Unable to decrypt sealed data');
        this.errors = errors;
        this.name = 'UnsealAggregateError';
    }
    addError(error) {
        this.errors.push(error);
    }
    toString() {
        return this.errors.map((e) => e.toString()).join('\n');
    }
}

const asyncInflateRaw = promisify(inflateRaw);
var DecryptionAlgorithm;
(function (DecryptionAlgorithm) {
    DecryptionAlgorithm["Aes256Gcm"] = "aes-256-gcm";
})(DecryptionAlgorithm || (DecryptionAlgorithm = {}));
const SEALED_HEADER = Buffer.from([0x9e, 0x85, 0xdc, 0xed]);
function isEventResponse(data) {
    return Boolean(data && typeof data === 'object' && 'products' in data);
}
/**
 * @private
 * */
function parseEventsResponse(unsealed) {
    const json = JSON.parse(unsealed);
    if (!isEventResponse(json)) {
        throw new Error('Sealed data is not valid events response');
    }
    return json;
}
/**
 * Decrypts the sealed response with the provided keys.
 * The SDK will try to decrypt the result with each key until it succeeds.
 * To learn more about sealed results visit: https://dev.fingerprint.com/docs/sealed-client-results
 */
async function unsealEventsResponse(sealedData, decryptionKeys) {
    const unsealed = await unseal(sealedData, decryptionKeys);
    return parseEventsResponse(unsealed);
}
/**
 * @private
 * */
async function unseal(sealedData, decryptionKeys) {
    if (sealedData.subarray(0, SEALED_HEADER.length).toString('hex') !== SEALED_HEADER.toString('hex')) {
        throw new Error('Invalid sealed data header');
    }
    const errors = new UnsealAggregateError([]);
    for (const decryptionKey of decryptionKeys) {
        switch (decryptionKey.algorithm) {
            case DecryptionAlgorithm.Aes256Gcm:
                try {
                    return await unsealAes256Gcm(sealedData, decryptionKey.key);
                }
                catch (e) {
                    errors.addError(new UnsealError(decryptionKey, e));
                    continue;
                }
            default:
                throw new Error(`Unsupported decryption algorithm: ${decryptionKey.algorithm}`);
        }
    }
    throw errors;
}
async function unsealAes256Gcm(sealedData, decryptionKey) {
    const nonceLength = 12;
    const nonce = sealedData.subarray(SEALED_HEADER.length, SEALED_HEADER.length + nonceLength);
    const authTagLength = 16;
    const authTag = sealedData.subarray(-authTagLength);
    const ciphertext = sealedData.subarray(SEALED_HEADER.length + nonceLength, -authTagLength);
    const decipher = createDecipheriv('aes-256-gcm', decryptionKey, nonce).setAuthTag(authTag);
    const compressed = Buffer.concat([decipher.update(ciphertext), decipher.final()]);
    const payload = await asyncInflateRaw(compressed);
    return payload.toString();
}

function isValidHmacSignature(signature, data, secret) {
    return signature === crypto.createHmac('sha256', secret).update(data).digest('hex');
}
/**
 * Verifies the HMAC signature extracted from the "fpjs-event-signature" header of the incoming request. This is a part of the webhook signing process, which is available only for enterprise customers.
 * If you wish to enable it, please contact our support: https://fingerprint.com/support
 *
 * @param {IsValidWebhookSignatureParams} params
 * @param {string} params.header - The value of the "fpjs-event-signature" header.
 * @param {Buffer} params.data - The raw data of the incoming request.
 * @param {string} params.secret - The secret key used to sign the request.
 *
 * @return {boolean} true if the signature is valid, false otherwise.
 *
 * @example
 * ```javascript
 * // Webhook endpoint handler
 * export async function POST(request: Request) {
 *   try {
 *     const secret = process.env.WEBHOOK_SIGNATURE_SECRET;
 *     const header = request.headers.get("fpjs-event-signature");
 *     const data = Buffer.from(await request.arrayBuffer());
 *
 *     if (!isValidWebhookSignature({ header, data, secret })) {
 *       return Response.json(
 *         { message: "Webhook signature is invalid." },
 *         { status: 403 },
 *       );
 *     }
 *
 *     return Response.json({ message: "Webhook received." });
 *   } catch (error) {
 *     return Response.json({ error }, { status: 500 });
 *   }
 * }
 * ```
 */
function isValidWebhookSignature(params) {
    const { header, data, secret } = params;
    const signatures = header.split(',');
    for (const signature of signatures) {
        const [version, hash] = signature.split('=');
        if (version === 'v1' && isValidHmacSignature(hash, data, secret)) {
            return true;
        }
    }
    return false;
}

export { ApiError, AuthenticationMode, CommonError403, CommonError429, DELETE_VISITS_ERRORS, DecryptionAlgorithm, DeleteVisit400Error, DeleteVisit403Error, DeleteVisit404Error, EVENT_ERRORS, EventError403, EventError404, FingerprintJsServerApiClient, RELATED_VISITORS_ERRORS, Region, SdkError, UPDATE_EVENT_ERRORS, UnsealAggregateError, UnsealError, UpdateEventError400, UpdateEventError403, UpdateEventError404, UpdateEventError409, VISITOR_ERRORS, VisitorsError400, VisitorsError403, VisitorsError404, VisitorsError429, getIntegrationInfo, getRequestPath, getRetryAfter, isDeleteVisitorsError, isEventError, isRelatedVisitorsError, isUpdateEventError, isValidWebhookSignature, isVisitorsError, parseEventsResponse, unseal, unsealEventsResponse };
